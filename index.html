<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Navier-Stokes Fluid Simulation</title>
    <style>
        /* Reset and Layout */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        /* The Canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevent scrolling on mobile */
        }

        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 20, 0.85);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            backdrop-filter: blur(5px);
            width: 220px;
            pointer-events: auto;
            user-select: none;
            transition: opacity 0.3s;
        }

        /* Hide UI on small screens initially or add toggle (simplified here to always show but small) */
        @media (max-width: 600px) {
            #ui-container {
                width: 180px;
                font-size: 12px;
                padding: 10px;
            }
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #00d2ff;
            text-align: center;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 4px;
            color: #ccc;
        }

        input[type=range] {
            width: 100%;
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #00d2ff;
            cursor: pointer;
            margin-top: -5px;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #444;
            border-radius: 2px;
        }

        button {
            width: 100%;
            padding: 8px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        button:hover {
            background: #444;
        }

        button:active {
            background: #00d2ff;
            color: black;
        }

        .stats {
            font-size: 10px;
            color: #666;
            text-align: center;
            margin-top: 10px;
        }
        
        .hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.3);
            pointer-events: none;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>Fluid Dynamics</h1>
        
        <div class="control-group">
            <label>Viscosity <span id="val-visc">0.000</span></label>
            <input type="range" id="visc" min="0" max="0.05" step="0.001" value="0.000">
        </div>

        <div class="control-group">
            <label>Diffusion <span id="val-diff">0.000</span></label>
            <input type="range" id="diff" min="0" max="0.01" step="0.0001" value="0.000">
        </div>

        <div class="control-group">
            <label>Input Strength <span id="val-amt">200</span></label>
            <input type="range" id="amt" min="50" max="500" step="10" value="200">
        </div>

        <div class="control-group">
            <label>Resolution (Requires Reset)</label>
            <select id="resolution" style="width: 100%; background: #222; color: white; border: 1px solid #444; padding: 4px;">
                <option value="64">Low (64x64)</option>
                <option value="128" selected>Medium (128x128)</option>
                <option value="200">High (200x200)</option>
            </select>
        </div>

        <button id="resetBtn">Clear / Reset</button>
        
        <div class="stats" id="fps-counter">FPS: 60</div>
    </div>

    <div class="hint">Click & Drag to interact</div>

    <canvas id="simCanvas"></canvas>

    <script>
        // Wrap everything in an IIFE to avoid global variable collisions (fix for "redeclaration of global property v")
        (function() {
            /**
             * FLUID SIMULATION CORE
             * Based on Jos Stam's "Real-Time Fluid Dynamics for Games"
             */

            // Configuration
            let N = 128;
            let iter = 10; // Solver iterations (higher = more accurate incompressible fluid, slower)
            let SCALE = 4; // Visual scaling factor

            // Physics Globals
            let size = (N + 2) * (N + 2);
            let dt = 0.1; // Time step
            let diff = 0.0000; // Diffusion
            let visc = 0.0000; // Viscosity
            
            // Arrays (Float32 for performance)
            let u, v, u_prev, v_prev; // Velocity (x, y) and previous states
            let dens, dens_prev; // Density (dye) and previous state

            // Canvas & Context
            const canvas = document.getElementById('simCanvas');
            const ctx = canvas.getContext('2d', { alpha: false }); // Alpha false for speed
            let width, height;

            // UI State
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let lastMouseX = 0, lastMouseY = 0;
            let hue = 0; // Color cycling

            // --- ALLOCATION ---
            function allocateBuffers() {
                size = (N + 2) * (N + 2);
                u = new Float32Array(size);
                v = new Float32Array(size);
                u_prev = new Float32Array(size);
                v_prev = new Float32Array(size);
                dens = new Float32Array(size);
                dens_prev = new Float32Array(size);
            }

            // --- UTILS ---
            // Convert 2D coordinates to 1D array index
            function IX(x, y) {
                return x + (N + 2) * y;
            }

            // --- SOLVER FUNCTIONS ---

            // Add sources (density or velocity) into the field
            function add_source(x, s, dt) {
                for (let i = 0; i < size; i++) {
                    x[i] += dt * s[i];
                }
            }

            // Set boundary conditions (walls)
            function set_bnd(b, x) {
                // b: 1 for horizontal walls (reflect x-velocity), 2 for vertical (reflect y-velocity), 0 for density
                
                // Edges
                for (let i = 1; i <= N; i++) {
                    x[IX(0, i)]     = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
                    x[IX(N + 1, i)] = b === 1 ? -x[IX(N, i)] : x[IX(N, i)];
                    x[IX(i, 0)]     = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
                    x[IX(i, N + 1)] = b === 2 ? -x[IX(i, N)] : x[IX(i, N)];
                }

                // Corners
                x[IX(0, 0)]         = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
                x[IX(0, N + 1)]     = 0.5 * (x[IX(1, N + 1)] + x[IX(0, N)]);
                x[IX(N + 1, 0)]     = 0.5 * (x[IX(N, 0)] + x[IX(N + 1, 1)]);
                x[IX(N + 1, N + 1)] = 0.5 * (x[IX(N, N + 1)] + x[IX(N + 1, N)]);
            }

            // Linear Solver (Gauss-Seidel relaxation)
            // Solves the diffusion equation and the Poisson equation for projection
            function lin_solve(b, x, x0, a, c) {
                const cRecip = 1.0 / c;
                for (let k = 0; k < iter; k++) {
                    for (let j = 1; j <= N; j++) {
                        let currentRow = j * (N + 2);
                        for (let i = 1; i <= N; i++) {
                            x[IX(i, j)] = (x0[IX(i, j)] + a * (
                                x[IX(i + 1, j)] + 
                                x[IX(i - 1, j)] + 
                                x[IX(i, j + 1)] + 
                                x[IX(i, j - 1)]
                            )) * cRecip;
                        }
                    }
                    set_bnd(b, x);
                }
            }

            // Diffuse: Fluids spread out over time due to viscosity
            function diffuse(b, x, x0, diff, dt) {
                let a = dt * diff * (N * N);
                lin_solve(b, x, x0, a, 1 + 4 * a);
            }

            // Advect: Move density/velocity along the velocity field
            // Uses back-tracing for stability
            function advect(b, d, d0, u, v, dt) {
                let i0, j0, i1, j1;
                let x, y, s0, t0, s1, t1;
                let dt0 = dt * N;

                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        x = i - dt0 * u[IX(i, j)];
                        y = j - dt0 * v[IX(i, j)];

                        // Clamp values
                        if (x < 0.5) x = 0.5;
                        if (x > N + 0.5) x = N + 0.5;
                        if (y < 0.5) y = 0.5;
                        if (y > N + 0.5) y = N + 0.5;

                        i0 = Math.floor(x);
                        i1 = i0 + 1;
                        j0 = Math.floor(y);
                        j1 = j0 + 1;

                        s1 = x - i0;
                        s0 = 1.0 - s1;
                        t1 = y - j0;
                        t0 = 1.0 - t1;

                        d[IX(i, j)] =
                            s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                            s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
                    }
                }
                set_bnd(b, d);
            }

            // Project: Enforce mass conservation (incompressibility)
            // Subtracts the gradient of the pressure field to make the velocity field divergence-free
            function project(u, v, p, div) {
                // Calculate Divergence
                let h = 1.0 / N;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        div[IX(i, j)] = -0.5 * h * (
                            u[IX(i + 1, j)] - u[IX(i - 1, j)] +
                            v[IX(i, j + 1)] - v[IX(i, j - 1)]
                        );
                        p[IX(i, j)] = 0;
                    }
                }
                set_bnd(0, div);
                set_bnd(0, p);

                // Solve Poisson equation for pressure
                lin_solve(0, p, div, 1, 4);

                // Subtract Gradient of pressure from velocity
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        u[IX(i, j)] -= 0.5 * (p[IX(i + 1, j)] - p[IX(i - 1, j)]) / h;
                        v[IX(i, j)] -= 0.5 * (p[IX(i, j + 1)] - p[IX(i, j - 1)]) / h;
                    }
                }
                set_bnd(1, u);
                set_bnd(2, v);
            }

            // Main physics step
            function fluid_step() {
                // 1. Velocity Step
                diffuse(1, u_prev, u, visc, dt);
                diffuse(2, v_prev, v, visc, dt);
                
                project(u_prev, v_prev, u, v);
                
                advect(1, u, u_prev, u_prev, v_prev, dt);
                advect(2, v, v_prev, u_prev, v_prev, dt);
                
                project(u, v, u_prev, v_prev);

                // 2. Density Step
                diffuse(0, dens_prev, dens, diff, dt);
                advect(0, dens, dens_prev, u, v, dt);

                // Fade out density over time (otherwise screen turns white eventually)
                for(let i=0; i<size; i++) {
                    dens[i] *= 0.995; 
                }
            }


            // --- RENDERING ---
            
            // Create an offscreen buffer for pixel manipulation
            let imgData;
            
            function initGraphics() {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
                
                // We render to a small canvas matching grid size, then scale up via CSS/Canvas transform
                // But to keep it sharp and fill screen, we'll draw rects (slower) or put pixels (faster)
                // For this implementation, we will draw rects for clarity on the grid structure, 
                // but optimize by scaling the context.
                
                // Actually, let's calculate cell size based on screen
                // This ensures the grid fills the screen exactly
            }

            function draw() {
                // Fill background
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, width, height);

                const cellWidth = Math.ceil(width / N);
                const cellHeight = Math.ceil(height / N);

                // Optimization: direct pixel manipulation is hard with dynamic scaling
                // So we use fillRect. It's heavy for 200x200 but okay for modern PCs.
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        let d = dens[IX(i, j)];
                        if (d > 0.01) {
                            // Color mapping based on density
                            // Higher density = brighter
                            // We mix in the global hue for rainbow effect
                            
                            // Clamp density for visualization
                            const val = Math.min(255, d * 255);
                            
                            // HSL for nice colors
                            // Hue cycles, Lightness based on density
                            ctx.fillStyle = `hsla(${hue}, 70%, 50%, ${Math.min(1, d)})`;
                            
                            // Draw cell
                            // We map grid coordinates (i,j) to screen coordinates
                            const x = (i - 1) * cellWidth;
                            const y = (j - 1) * cellHeight;
                            
                            // Using +1 on dimensions to avoid sub-pixel gaps
                            ctx.fillRect(x, y, cellWidth, cellHeight);
                        }
                    }
                }
                
                // Cycle hue
                hue += 0.5;
                if(hue > 360) hue = 0;
            }


            // --- INTERACTION ---

            function handleInput() {
                if (!isMouseDown) return;

                // Calculate grid coordinates
                const cellWidth = width / N;
                const cellHeight = height / N;

                const i = Math.floor(mouseX / cellWidth) + 1;
                const j = Math.floor(mouseY / cellHeight) + 1;

                // Add Density
                if (i > 0 && i <= N && j > 0 && j <= N) {
                    const amt = parseFloat(document.getElementById('amt').value);
                    dens[IX(i, j)] += amt;
                    
                    // Add Velocity based on mouse movement
                    const force = 5.0;
                    const dx = (mouseX - lastMouseX) * force;
                    const dy = (mouseY - lastMouseY) * force;

                    u[IX(i, j)] += dx;
                    v[IX(i, j)] += dy;
                }

                lastMouseX = mouseX;
                lastMouseY = mouseY;
            }

            // Event Listeners
            canvas.addEventListener('mousedown', e => {
                isMouseDown = true;
                lastMouseX = mouseX = e.clientX;
                lastMouseY = mouseY = e.clientY;
            });

            canvas.addEventListener('mousemove', e => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                handleInput();
            });

            window.addEventListener('mouseup', () => isMouseDown = false);
            
            // Touch support
            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                isMouseDown = true;
                lastMouseX = mouseX = e.touches[0].clientX;
                lastMouseY = mouseY = e.touches[0].clientY;
            }, {passive: false});

            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
                handleInput();
            }, {passive: false});
            
            window.addEventListener('touchend', () => isMouseDown = false);

            window.addEventListener('resize', initGraphics);

            // --- UI BINDING ---
            const uiVisc = document.getElementById('visc');
            const uiDiff = document.getElementById('diff');
            const uiAmt = document.getElementById('amt');
            const uiRes = document.getElementById('resolution');
            const uiReset = document.getElementById('resetBtn');

            uiVisc.addEventListener('input', (e) => {
                visc = parseFloat(e.target.value);
                document.getElementById('val-visc').innerText = visc.toFixed(4);
            });

            uiDiff.addEventListener('input', (e) => {
                diff = parseFloat(e.target.value);
                document.getElementById('val-diff').innerText = diff.toFixed(4);
            });
            
            uiAmt.addEventListener('input', (e) => {
                document.getElementById('val-amt').innerText = e.target.value;
            });

            uiRes.addEventListener('change', (e) => {
                N = parseInt(e.target.value);
                restart();
            });

            uiReset.addEventListener('click', restart);

            // --- MAIN LOOP ---

            let lastTime = 0;
            let fpsElement = document.getElementById('fps-counter');
            let frames = 0;
            let timeAccumulator = 0;

            function loop(timestamp) {
                // FPS Counter
                const delta = timestamp - lastTime;
                lastTime = timestamp;
                timeAccumulator += delta;
                frames++;
                if (timeAccumulator > 1000) {
                    fpsElement.innerText = `FPS: ${frames} | Grid: ${N}x${N}`;
                    frames = 0;
                    timeAccumulator = 0;
                }

                fluid_step();
                draw();
                requestAnimationFrame(loop);
            }

            function restart() {
                allocateBuffers();
                initGraphics();
                // Clear background
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, width, height);
            }

            // Start
            restart();
            requestAnimationFrame(loop);
        })(); // End IIFE
    </script>
</body>
</html>
