<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Performance Navier-Stokes Fluid Simulation</title>
    <style>
        /* Reset and Layout */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        /* The Canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* Rendering: pixelated gives a crisp retro look (good for grids),
               but auto/smooth is often better for fluids. 
               We use standard scaling here for a smooth liquid look.
            */
            image-rendering: auto; 
            touch-action: none;
        }

        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 20, 0.85);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            backdrop-filter: blur(5px);
            width: 220px;
            pointer-events: auto;
            user-select: none;
            transition: opacity 0.3s;
            z-index: 10;
        }

        @media (max-width: 600px) {
            #ui-container {
                width: 180px;
                font-size: 12px;
                padding: 10px;
            }
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #00d2ff;
            text-align: center;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 4px;
            color: #ccc;
        }

        input[type=range] {
            width: 100%;
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #00d2ff;
            cursor: pointer;
            margin-top: -5px;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #444;
            border-radius: 2px;
        }

        button {
            width: 100%;
            padding: 8px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        button:hover {
            background: #444;
        }

        button:active {
            background: #00d2ff;
            color: black;
        }

        .stats {
            font-size: 10px;
            color: #666;
            text-align: center;
            margin-top: 10px;
        }
        
        .hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.3);
            pointer-events: none;
            font-size: 14px;
            z-index: 5;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>Fluid Dynamics</h1>
        
        <div class="control-group">
            <label>Viscosity <span id="val-visc">0.000</span></label>
            <input type="range" id="visc" min="0" max="0.05" step="0.001" value="0.000">
        </div>

        <div class="control-group">
            <label>Diffusion <span id="val-diff">0.000</span></label>
            <input type="range" id="diff" min="0" max="0.01" step="0.0001" value="0.000">
        </div>

        <div class="control-group">
            <label>Input Strength <span id="val-amt">200</span></label>
            <input type="range" id="amt" min="50" max="500" step="10" value="200">
        </div>

        <div class="control-group">
            <label>Resolution</label>
            <select id="resolution" style="width: 100%; background: #222; color: white; border: 1px solid #444; padding: 4px;">
                <option value="64">Low (64x64)</option>
                <option value="128" selected>Medium (128x128)</option>
                <option value="256">High (256x256)</option>
                <option value="300">Ultra (300x300)</option>
            </select>
        </div>

        <button id="resetBtn">Clear / Reset</button>
        
        <div class="stats" id="fps-counter">FPS: 60</div>
    </div>

    <div class="hint">Click & Drag to interact</div>

    <canvas id="simCanvas"></canvas>

    <script>
        (function() {
            /**
             * OPTIMIZED FLUID SIMULATION
             * - Uses direct pixel manipulation (ImageData)
             * - Inlines math in hot loops
             * - Uses CSS for scaling rather than drawing rectangles
             */

            // Configuration
            let N = 128;
            let iter = 10;
            
            // Physics Globals
            let size = (N + 2) * (N + 2);
            let dt = 0.1;
            let diff = 0.0000;
            let visc = 0.0000;
            
            // Arrays (Float32 for performance)
            let u, v, u_prev, v_prev;
            let dens, dens_prev;

            // Canvas & Context
            const canvas = document.getElementById('simCanvas');
            // 'willReadFrequently' optimization for some browsers when using getImageData/putImageData
            const ctx = canvas.getContext('2d', { alpha: false, willReadFrequently: true }); 
            let imageData;
            let data; // Reference to imageData.data

            // UI State
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let lastMouseX = 0, lastMouseY = 0;
            let hue = 0;
            let currentR = 0, currentG = 0, currentB = 0; // Current base color

            // --- ALLOCATION ---
            function allocateBuffers() {
                size = (N + 2) * (N + 2);
                u = new Float32Array(size);
                v = new Float32Array(size);
                u_prev = new Float32Array(size);
                v_prev = new Float32Array(size);
                dens = new Float32Array(size);
                dens_prev = new Float32Array(size);

                // Set internal canvas resolution to match grid size exactly
                // CSS will handle stretching it to the screen
                canvas.width = N;
                canvas.height = N;
                
                // Create Image Buffer
                imageData = ctx.createImageData(N, N);
                data = imageData.data;
            }

            function IX(x, y) {
                return x + (N + 2) * y;
            }

            // --- SOLVER FUNCTIONS ---

            function set_bnd(b, x) {
                // b: 1=horizontal, 2=vertical, 0=density
                // Edges
                // Inline IX logic for slight perf gain in loops
                const N2 = N + 2;
                
                for (let i = 1; i <= N; i++) {
                    x[i]             = b === 1 ? -x[1 + i*N2] : x[1 + i*N2];          // Left wall
                    x[(N + 1) + i*N2] = b === 1 ? -x[N + i*N2] : x[N + i*N2];         // Right wall
                    x[i * N2]         = b === 2 ? -x[i + N2] : x[i + N2];             // Top wall
                    x[i + (N+1)*N2]   = b === 2 ? -x[i + N*N2] : x[i + N*N2];         // Bottom wall
                }

                // Corners
                x[0]                 = 0.5 * (x[1] + x[N2]);
                x[(N + 1) * N2]      = 0.5 * (x[1 + (N + 1) * N2] + x[N2 * N]); // Bottom Left? (indices need care)
                // Simplify corner logic to basic IX calls for safety as they run only 4 times
                x[IX(0, 0)]         = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
                x[IX(0, N + 1)]     = 0.5 * (x[IX(1, N + 1)] + x[IX(0, N)]);
                x[IX(N + 1, 0)]     = 0.5 * (x[IX(N, 0)] + x[IX(N + 1, 1)]);
                x[IX(N + 1, N + 1)] = 0.5 * (x[IX(N, N + 1)] + x[IX(N + 1, N)]);
            }

            // Heavily optimized linear solver
            function lin_solve(b, x, x0, a, c) {
                const cRecip = 1.0 / c;
                const N2 = N + 2; // Precompute row stride

                for (let k = 0; k < iter; k++) {
                    for (let j = 1; j <= N; j++) {
                        let currentIdx = j * N2 + 1; // Start of row j (at i=1)
                        // Using a tight loop with incrementing index is faster than recalc IX() every time
                        for (let i = 1; i <= N; i++) {
                            // Neighbor indices: 
                            // i+1 -> currentIdx + 1
                            // i-1 -> currentIdx - 1
                            // j+1 -> currentIdx + N2
                            // j-1 -> currentIdx - N2
                            
                            x[currentIdx] = (x0[currentIdx] + a * (
                                x[currentIdx + 1] + 
                                x[currentIdx - 1] + 
                                x[currentIdx + N2] + 
                                x[currentIdx - N2]
                            )) * cRecip;
                            
                            currentIdx++;
                        }
                    }
                    set_bnd(b, x);
                }
            }

            function diffuse(b, x, x0, diff, dt) {
                let a = dt * diff * (N * N);
                lin_solve(b, x, x0, a, 1 + 4 * a);
            }

            function advect(b, d, d0, u, v, dt) {
                let i0, j0, i1, j1;
                let x, y, s0, t0, s1, t1;
                let dt0 = dt * N;
                const Nfloat = N; // float N

                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const index = IX(i, j);
                        x = i - dt0 * u[index];
                        y = j - dt0 * v[index];

                        if (x < 0.5) x = 0.5;
                        if (x > Nfloat + 0.5) x = Nfloat + 0.5;
                        if (i0 = x | 0, i1 = i0 + 1, x < 0.5) i0=0, i1=0; // manual floor using bitwise OR

                        if (y < 0.5) y = 0.5;
                        if (y > Nfloat + 0.5) y = Nfloat + 0.5;
                        j0 = y | 0; // Fast floor
                        j1 = j0 + 1;

                        s1 = x - i0;
                        s0 = 1.0 - s1;
                        t1 = y - j0;
                        t0 = 1.0 - t1;

                        const row0 = j0 * (N + 2);
                        const row1 = j1 * (N + 2);

                        d[index] =
                            s0 * (t0 * d0[i0 + row0] + t1 * d0[i0 + row1]) +
                            s1 * (t0 * d0[i1 + row0] + t1 * d0[i1 + row1]);
                    }
                }
                set_bnd(b, d);
            }

            function project(u, v, p, div) {
                const N2 = N + 2;
                const h = 1.0 / N;
                
                for (let j = 1; j <= N; j++) {
                    let id = j * N2 + 1;
                    for (let i = 1; i <= N; i++) {
                        div[id] = -0.5 * h * (
                            u[id + 1] - u[id - 1] +
                            v[id + N2] - v[id - N2]
                        );
                        p[id] = 0;
                        id++;
                    }
                }
                set_bnd(0, div);
                set_bnd(0, p);

                lin_solve(0, p, div, 1, 4);

                for (let j = 1; j <= N; j++) {
                    let id = j * N2 + 1;
                    for (let i = 1; i <= N; i++) {
                        u[id] -= 0.5 * (p[id + 1] - p[id - 1]) / h;
                        v[id] -= 0.5 * (p[id + N2] - p[id - N2]) / h;
                        id++;
                    }
                }
                set_bnd(1, u);
                set_bnd(2, v);
            }

            function fluid_step() {
                // Physics steps remain conceptually same, just optimized internals
                diffuse(1, u_prev, u, visc, dt);
                diffuse(2, v_prev, v, visc, dt);
                
                project(u_prev, v_prev, u, v);
                
                advect(1, u, u_prev, u_prev, v_prev, dt);
                advect(2, v, v_prev, u_prev, v_prev, dt);
                
                project(u, v, u_prev, v_prev);

                diffuse(0, dens_prev, dens, diff, dt);
                advect(0, dens, dens_prev, u, v, dt);

                // Fade out
                // Using a loop here is fast enough for typed arrays
                // We could use .fill if we wanted to clear, but we are scaling
                for(let i=0; i<size; i++) {
                    dens[i] *= 0.995; 
                }
            }


            // --- RENDERING OPTIMIZED ---
            
            // Helper to convert HSL to RGB manually (much faster than CSS string parsing)
            function updateBaseColor() {
                // HSL to RGB conversion approximation
                const h = hue % 360;
                const s = 70 / 100;
                const l = 50 / 100;

                const c = (1 - Math.abs(2 * l - 1)) * s;
                const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                const m = l - c / 2;

                let r = 0, g = 0, b = 0;

                if (0 <= h && h < 60) { r = c; g = x; b = 0; }
                else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
                else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
                else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
                else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
                else if (300 <= h && h < 360) { r = c; g = 0; b = x; }

                currentR = (r + m) * 255;
                currentG = (g + m) * 255;
                currentB = (b + m) * 255;
            }

            function draw() {
                // Update global color
                updateBaseColor();
                hue += 0.5;

                // Optimization: Write directly to the pixel buffer
                // The buffer is N x N pixels.
                // dens[] is size (N+2)*(N+2), so we must map correctly.
                
                let p = 0; // pixel index (0 to 4*N*N)
                
                for (let j = 1; j <= N; j++) {
                    let fluidIdx = j * (N + 2) + 1; // Start of row in fluid array
                    
                    for (let i = 1; i <= N; i++) {
                        const d = dens[fluidIdx];
                        
                        // If density is very low, draw black (or background)
                        if (d > 0.001) {
                            // Simple lighting: density affects alpha/brightness
                            // Clamp density to 0-1 range for math
                            const alpha = d > 1 ? 1 : d;
                            
                            // Set pixel data (R, G, B, A)
                            data[p]     = currentR;
                            data[p + 1] = currentG;
                            data[p + 2] = currentB;
                            data[p + 3] = alpha * 255; // Alpha 0-255
                        } else {
                            data[p + 3] = 0; // Transparent (black bg shows through if cleared)
                            // Or just set to black opaque:
                            data[p] = 0; data[p+1] = 0; data[p+2] = 0; data[p+3] = 255; 
                        }

                        p += 4;
                        fluidIdx++;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
            }


            // --- INTERACTION ---

            function handleInput() {
                if (!isMouseDown) return;

                // Map screen coordinates to simulation grid coordinates
                // Canvas is scaled via CSS, so we need the bounding box
                const rect = canvas.getBoundingClientRect();
                
                // Scale factor between screen pixels and canvas internal pixels
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                // Mouse Pos in Grid Coords
                const gridX = (mouseX - rect.left) * scaleX;
                const gridY = (mouseY - rect.top) * scaleY;
                
                // Floor to get index
                const i = Math.floor(gridX);
                const j = Math.floor(gridY);

                // Add Density
                if (i > 0 && i <= N && j > 0 && j <= N) {
                    const amt = parseFloat(document.getElementById('amt').value);
                    dens[IX(i, j)] += amt;
                    
                    // Add Velocity based on mouse movement
                    const force = 5.0;
                    // Calculate velocity in grid coords
                    const prevGridX = (lastMouseX - rect.left) * scaleX;
                    const prevGridY = (lastMouseY - rect.top) * scaleY;

                    const dx = (gridX - prevGridX) * force;
                    const dy = (gridY - prevGridY) * force;

                    u[IX(i, j)] += dx;
                    v[IX(i, j)] += dy;
                }

                lastMouseX = mouseX;
                lastMouseY = mouseY;
            }

            // Event Listeners
            canvas.addEventListener('mousedown', e => {
                isMouseDown = true;
                lastMouseX = mouseX = e.clientX;
                lastMouseY = mouseY = e.clientY;
            });

            canvas.addEventListener('mousemove', e => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                handleInput();
            });

            window.addEventListener('mouseup', () => isMouseDown = false);
            
            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                isMouseDown = true;
                lastMouseX = mouseX = e.touches[0].clientX;
                lastMouseY = mouseY = e.touches[0].clientY;
            }, {passive: false});

            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
                handleInput();
            }, {passive: false});
            
            window.addEventListener('touchend', () => isMouseDown = false);

            // Resize isn't strictly needed for buffer size anymore since buffer is fixed N*N
            // But we might want to re-grab rects on input if layout shifts.
            // Using CSS scaling means we don't need to reallocate buffers on resize!

            // --- UI BINDING ---
            const uiVisc = document.getElementById('visc');
            const uiDiff = document.getElementById('diff');
            const uiAmt = document.getElementById('amt');
            const uiRes = document.getElementById('resolution');
            const uiReset = document.getElementById('resetBtn');

            uiVisc.addEventListener('input', (e) => {
                visc = parseFloat(e.target.value);
                document.getElementById('val-visc').innerText = visc.toFixed(4);
            });

            uiDiff.addEventListener('input', (e) => {
                diff = parseFloat(e.target.value);
                document.getElementById('val-diff').innerText = diff.toFixed(4);
            });
            
            uiAmt.addEventListener('input', (e) => {
                document.getElementById('val-amt').innerText = e.target.value;
            });

            uiRes.addEventListener('change', (e) => {
                N = parseInt(e.target.value);
                restart();
            });

            uiReset.addEventListener('click', restart);

            // --- MAIN LOOP ---

            let lastTime = 0;
            let fpsElement = document.getElementById('fps-counter');
            let frames = 0;
            let timeAccumulator = 0;

            function loop(timestamp) {
                // FPS Counter
                const delta = timestamp - lastTime;
                lastTime = timestamp;
                timeAccumulator += delta;
                frames++;
                if (timeAccumulator > 1000) {
                    fpsElement.innerText = `FPS: ${frames} | Grid: ${N}x${N}`;
                    frames = 0;
                    timeAccumulator = 0;
                }

                fluid_step();
                draw();
                requestAnimationFrame(loop);
            }

            function restart() {
                allocateBuffers();
                // Clear buffers to black opaque
                for(let i=0; i<data.length; i+=4) {
                    data[i] = 0; data[i+1] = 0; data[i+2] = 0; data[i+3] = 255;
                }
                ctx.putImageData(imageData, 0, 0);
            }

            // Start
            restart();
            requestAnimationFrame(loop);
        })(); 
    </script>
</body>
</html>
